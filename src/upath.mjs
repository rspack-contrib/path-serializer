// @ts-nocheck
/**
 * upath http://github.com/anodynos/upath/
 *
 * A proxy to `path`, replacing `\` with `/` for all results (supports UNC paths) & new methods to normalize & join keeping leading `./` and add, change, default, trim file extensions.
 * Version 2.0.1 - Compiled on 2020-11-07 16:59:47
 * Repository git://github.com/anodynos/upath
 * Copyright(c) 2020 Angelos Pikoulas <agelos.pikoulas@gmail.com>
 * License MIT
 */

// Generated by uRequire v0.7.0-beta.33 target: 'lib' template: 'nodejs'
import path from 'node:path';

const VERSION = '2.0.1'; // injected by urequire-rc-inject-version

let extraFn;
let extraFunctions;
let isFunction;
let isString;
let isValidExt;
let name;
let propName;
let propValue;
let toUnix;
let upath;
const slice = [].slice;
const indexOf =
  [].indexOf ||
  function (item) {
    for (let i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item) return i;
    }
    return -1;
  };
const hasProp = {}.hasOwnProperty;
isFunction = (val) => typeof val === 'function';
isString = (val) =>
  typeof val === 'string' ||
  (!!val &&
    typeof val === 'object' &&
    Object.prototype.toString.call(val) === '[object String]');
upath.VERSION =
  typeof VERSION !== 'undefined' && VERSION !== null ? VERSION : 'NO-VERSION';
toUnix = (p) => {
  p = p.replace(/\\/g, '/');
  p = p.replace(/(?<!^)\/+/g, '/');
  return p;
};
for (propName in path) {
  propValue = path[propName];
  if (isFunction(propValue)) {
    upath[propName] = ((propName) => () => {
      let args;
      let result;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      args = args.map((p) => {
        if (isString(p)) {
          return toUnix(p);
        }
        return p;
      });
      result = path[propName].apply(path, args);
      if (isString(result)) {
        return toUnix(result);
      }
      return result;
    })(propName);
  } else {
    upath[propName] = propValue;
  }
}
upath.sep = '/';
extraFunctions = {
  toUnix: toUnix,
  normalizeSafe: (p) => {
    let result;
    p = toUnix(p);
    result = upath.normalize(p);
    if (
      p.startsWith('./') &&
      !result.startsWith('./') &&
      !result.startsWith('..')
    ) {
      result = `./${result}`;
    } else if (p.startsWith('//') && !result.startsWith('//')) {
      if (p.startsWith('//./')) {
        result = `//.${result}`;
      } else {
        result = `/${result}`;
      }
    }
    return result;
  },
  normalizeTrim: (p) => {
    p = upath.normalizeSafe(p);
    if (p.endsWith('/')) {
      return p.slice(0, +(p.length - 2) + 1 || 9000000000);
    }
    return p;
  },
  joinSafe: () => {
    let p;
    let p0;
    let result;
    p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    result = upath.join.apply(null, p);
    if (p.length > 0) {
      p0 = toUnix(p[0]);
      if (
        p0.startsWith('./') &&
        !result.startsWith('./') &&
        !result.startsWith('..')
      ) {
        result = `./${result}`;
      } else if (p0.startsWith('//') && !result.startsWith('//')) {
        if (p0.startsWith('//./')) {
          result = `//.${result}`;
        } else {
          result = `/${result}`;
        }
      }
    }
    return result;
  },
  addExt: (file, ext) => {
    if (!ext) {
      return file;
    }
    if (ext[0] !== '.') {
      ext = `.${ext}`;
    }
    return file + (file.endsWith(ext) ? '' : ext);
  },
  trimExt: (filename, ignoreExts, maxSize) => {
    let oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename.slice(
        0,
        +(filename.length - oldExt.length - 1) + 1 || 9000000000,
      );
    }
    return filename;
  },
  removeExt: (filename, ext) => {
    if (!ext) {
      return filename;
    }
    ext = ext[0] === '.' ? ext : `.${ext}`;
    if (upath.extname(filename) === ext) {
      return upath.trimExt(filename, [], ext.length);
    }
    return filename;
  },
  changeExt: (filename, ext, ignoreExts, maxSize) => {
    if (maxSize == null) {
      maxSize = 7;
    }
    return (
      upath.trimExt(filename, ignoreExts, maxSize) +
      (!ext ? '' : ext[0] === '.' ? ext : `.${ext}`)
    );
  },
  defaultExt: (filename, ext, ignoreExts, maxSize) => {
    let oldExt;
    if (maxSize == null) {
      maxSize = 7;
    }
    oldExt = upath.extname(filename);
    if (isValidExt(oldExt, ignoreExts, maxSize)) {
      return filename;
    }
    return upath.addExt(filename, ext);
  },
};
isValidExt = (ext, ignoreExts, maxSize) => {
  if (ignoreExts == null) {
    ignoreExts = [];
  }
  return (
    ext &&
    ext.length <= maxSize &&
    indexOf.call(
      ignoreExts.map((e) => (e && e[0] !== '.' ? '.' : '') + e),
      ext,
    ) < 0
  );
};
for (name in extraFunctions) {
  if (!hasProp.call(extraFunctions, name)) continue;
  extraFn = extraFunctions[name];
  if (upath[name] !== void 0) {
    throw new Error(`path.${name} already exists.`);
  }
  upath[name] = extraFn;
}

export { upath };
